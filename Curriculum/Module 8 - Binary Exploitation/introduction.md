# Binary Exploitation

In this module, students will learn about binary exploitation techniques and vulnerabilities in software that can be exploited to take control of a system. The module will cover various techniques for identifying, exploiting, and defending against common vulnerabilities in binary programs.

## Learning Objectives

- Understand the basic principles of binary exploitation
- Identify common vulnerabilities in binary programs
- Use tools such as gdb and pwntools to analyze and exploit binary vulnerabilities
- Implement basic defenses against common binary exploits

## Topics Covered

1. Introduction to Binary Exploitation
2. Basic Stack Overflows
3. Return Oriented Programming (ROP)
4. Format String Vulnerabilities
5. Heap Exploitation
6. Defending Against Binary Exploits

By the end of this module, students should have a basic understanding of binary exploitation techniques and the ability to identify and exploit common vulnerabilities in binary programs. They should also be able to implement basic defenses


### Introduction to Binary Exploitation
Many programs are written in memory unsafe languages like C/C++.
For instance, operating systems, browsers, the runtime of languages like Java.

**Binary exploitation** is the art of finding vulnerabilities in programs and leveraging them to gain control over the entire program.
Conversely, **memory safety** tries to avoid these types vulnerabilities.

Typical examples of memory safety violations that can be exploited in binaries are:

- Overflows and overreads on stack and heap
- Invalid pointers
- Race conditions
- Invalid frees/Use after free
- Null pointer dereferences
- Uninitialized memory accesses


A program is considered to be free of memory safety violations if there are no exploitable vulnerabilities given.
Programming languages like *Rust* try to guarantee that there are no memory safety violations[2].  



A **memory safety violation** can be further classified into the two main types **spatial** and **temporal** violations.
A spatial violation accesses memory that is considered to be out of bounds.
For instance, reading more bytes of a memory buffer than the actual defined size.

Examples for spatial memory safety violations are:
- Buffer overflows
- Out-of-bounds reads
- Null pointer dereferences

Temporal memory safety violations access memory that is considered to be invalid.

Typical examples are:
- Use after free 
- Double free
- Use of uninitialized memory

A list of vulnerabilities by type can be found [here](http://www.cvedetails.com/vulnerabilities-by-types.php).

### Basic Stack Overflows
The stack is one of the most important data structures used in modern computer systems.
The stack has two main operations called *push* and *pop*.
A push operation adds an element to the stack, while the pop takes an element from the stack.
Important registers on x86 are the stack pointer (`esp`/`rsp`), pointing to the current element in the stack and the base pointer, pointing to the start address of the stack. 
A *stack frame* defines the full set of elements in the stack , i.e. all elements starting from the base pointer (start address) to the stack pointer.






A *buffer* is a consecutive chunk of memory storing the same type of memory with a fixed boundary.
A buffer is defined by a start address and size. 
The snippet below shows a typical memory allocation on the stack.
Here, the string "Some data" is copied to buffer.
However, this copy operation does not check the length of the buffer. 

```C
char buffer[10];
strcpy(buffer,"Some data");
```

If the string exceeds the length of the buffer data will be overwritten that is out-of-bounds.
Check out the example in the examples folder, run the `make` command and start the binary `./simple_buffer`.



### Resources
[1] https://people.eecs.berkeley.edu/~dawnsong/papers/Oakland13-SoK-CR.pdf
[2] https://www.embedded.com/memory-safety-in-rust/